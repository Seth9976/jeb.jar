package com.pnfsoftware.jebglobal;

import com.pnfsoftware.jeb.core.units.code.asm.analyzer.IMethodStackMemoryModel;
import com.pnfsoftware.jeb.core.units.code.asm.analyzer.IStackframeManager;
import com.pnfsoftware.jeb.core.units.code.asm.decompiler.IERoutineContext;
import com.pnfsoftware.jeb.core.units.code.asm.decompiler.ir.IEStackManager;
import com.pnfsoftware.jeb.core.units.code.asm.decompiler.ir.IEVar;
import com.pnfsoftware.jeb.core.units.code.asm.decompiler.ir.IWildcardType;
import com.pnfsoftware.jeb.core.units.code.asm.items.INativeContinuousItem;
import com.pnfsoftware.jeb.core.units.code.asm.items.INativeDataItem;
import com.pnfsoftware.jeb.core.units.code.asm.type.INativeType;
import com.pnfsoftware.jeb.core.units.code.asm.type.ITypeManager;
import com.pnfsoftware.jeb.core.units.code.asm.type.TypeUtil;
import com.pnfsoftware.jeb.util.base.Assert;
import com.pnfsoftware.jeb.util.format.Strings;
import com.pnfsoftware.jeb.util.logging.StructuredLogger;
import com.pnfsoftware.jeb.util.serialization.annotations.Ser;
import com.pnfsoftware.jeb.util.serialization.annotations.SerId;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;

@Ser
public class akl implements IEStackManager {
   private static final StructuredLogger wS = aco.pC(akl.class);
   @SerId(1)
   aki pC;
   @SerId(2)
   int A;
   @SerId(3)
   int kS;

   public akl(aki var1) {
      this.pC = var1;
      this.A = var1.getGlobalContext().getAddressBitsize();
      if (this.A % 8 != 0) {
         throw new IllegalArgumentException("The normal slot bitsize must be a multiple of 8");
      } else {
         this.kS = this.A / 8;
      }
   }

   @Override
   public IERoutineContext getRoutineContext() {
      return this.pC;
   }

   @Override
   public int getNormalSlotBitsize() {
      return this.A;
   }

   @Override
   public int getNormalSlotSize() {
      return this.kS;
   }

   @Override
   public Long getLowestVariableOffset() {
      IEVar var1 = this.pC.E.A(33554432, Integer.MAX_VALUE);
      return var1 == null ? null : var1.getAddress();
   }

   @Override
   public Long getHighestVariableOffset() {
      IEVar var1 = this.pC.E.kS(33554432, Integer.MAX_VALUE);
      return var1 == null ? null : var1.getAddress();
   }

   @Override
   public Long getHighestVariableOffsetEnd() {
      IEVar var1 = this.pC.E.kS(33554432, Integer.MAX_VALUE);
      return var1 == null ? null : var1.getAddress() + var1.getBitsize() / 8;
   }

   @Override
   public boolean canCreateVariable(long var1, int var3) {
      int var4 = 1073741824 + (int)(var1 * 8L);
      if (var4 >= 33554432 && var4 + var3 <= Integer.MAX_VALUE) {
         return this.pC.E.wS(var4, var3);
      } else {
         throw new RuntimeException("Illegal stack slot");
      }
   }

   @Override
   public boolean hasVariables() {
      return !this.pC.E.pC(33554432, Integer.MAX_VALUE).isEmpty();
   }

   @Override
   public Collection getVariables() {
      return this.pC.E.pC(33554432, Integer.MAX_VALUE);
   }

   @Override
   public IEVar getVariable(long var1) {
      int var3 = 1073741824 + (int)(var1 * 8L);
      if (var3 < 33554432) {
         throw new RuntimeException("Illegal stack slot");
      } else {
         return this.pC.E.A(var3);
      }
   }

   @Override
   public IEVar getVariableAtSlot(int var1) {
      int var2 = 1073741824 + var1 * this.A;
      if (var2 >= 33554432 && var2 < Integer.MAX_VALUE) {
         IEVar var3 = this.pC.E.A(var2);
         return var3 == null ? null : var3;
      } else {
         throw new RuntimeException("Illegal stack slot");
      }
   }

   @Override
   public IEVar removeVariable(IEVar var1) {
      if (!var1.isStackVariable()) {
         throw new RuntimeException("Not a stack variable");
      } else {
         return this.removeVariable(var1.getAddress());
      }
   }

   @Override
   public IEVar removeVariable(long var1) {
      int var3 = 1073741824 + (int)(var1 * 8L);
      if (var3 < 33554432) {
         throw new RuntimeException("Illegal stack slot");
      } else {
         return this.pC.E.pC(var3);
      }
   }

   @Override
   public boolean canClearNativeStack(long var1, long var3) {
      IStackframeManager var5 = this.pC.getRoutine().getData().getStackframeManager();

      for (INativeContinuousItem var7 : var5.getModel().getItemsInRange(var1, true, var3, true).values()) {
         if (!var7.isAutoGenerated()) {
            return false;
         }
      }

      return true;
   }

   @Override
   public void clearNativeStack(long var1, long var3) {
      IStackframeManager var5 = this.pC.getRoutine().getData().getStackframeManager();
      var5.undefineItems(var1, var3);
   }

   @Override
   public IEVar createStackItem(long var1, int var3) {
      int var6 = var3;
      IStackframeManager var7 = this.pC.getRoutine().getData().getStackframeManager();
      IMethodStackMemoryModel var8 = this.pC.getRoutine().getData().getStackframeModel();
      ITypeManager var9 = this.pC.getWildcardTypeManager().getNativeTypeManager();
      Object var11 = var8.getItemOver(var1);
      IEVar var10;
      if (var11 == null) {
         if (!this.canCreateVariable(var1, var3)) {
            return null;
         }

         INativeContinuousItem var12 = var8.getNextItem(var1);
         if (var12 != null && var12.getMemoryAddress() < var1 + var3 / 8) {
            var6 = 8;
         }

         var10 = this.createPureStackItem(var1, var6);
         INativeType var13 = var9.getInteger(var6 / 8, true);
         if (var13 != null) {
            var11 = var7.defineItem(var1, var13);
            Assert.a(var11 != null);
            ((INativeContinuousItem)var11).setAutoGenerated(true);
         }

         Object[] var10000 = new Object[]{var10, var11};
      } else {
         long var4 = ((INativeContinuousItem)var11).getMemoryAddress();
         var10 = this.getVariable(var4);
         if (var10 != null) {
            if (var10.getBitsize() == var3) {
               return var10;
            }

            return null;
         }

         if (!(var11 instanceof INativeDataItem)) {
            return null;
         }

         INativeType var15 = TypeUtil.getFirstSimpleType(((INativeDataItem)var11).getType());
         if (var15 != null) {
            var6 = 8 * var15.getSize();
         }

         var10 = this.createPureStackItem(var4, var6);
         String var16 = ((INativeContinuousItem)var11).getName(true);
         if (var16 != null) {
            ((aku)var10).pC(var16);
         }

         Object[] var17 = new Object[]{var10};
      }

      return var10;
   }

   @Override
   public IEVar createPureStackItem(long var1, int var3) {
      int var4 = 1073741824 + (int)(var1 * 8L);
      if (var4 >= 33554432 && var4 + var3 <= Integer.MAX_VALUE) {
         IEVar var5 = this.pC.E.A(var4);
         if (var5 != null) {
            if (var5.getBitsize() != var3) {
               throw new RuntimeException(
                  Strings.ff("Variable \"%s\" was already defined with a different bitsize (%d != %d)", var5.getName(), var3, var5.getBitsize())
               );
            } else {
               return var5;
            }
         } else {
            String var6;
            if (var1 >= 0L) {
               var6 = Strings.ff("par%02X", var1);
            } else {
               var6 = Strings.ff("var%02X", -var1);
            }

            var5 = this.pC.E.pC(var4, var6, var3, var1, true);
            Assert.a(var5 != null);
            return var5;
         }
      } else {
         throw new RuntimeException("Illegal stack slot");
      }
   }

   @Override
   public IWildcardType getActualStackItemType(long var1) {
      IMethodStackMemoryModel var3 = this.pC.getRoutine().getData().getStackframeModel();
      INativeContinuousItem var4 = var3.getItemAt(var1);
      if (!(var4 instanceof INativeDataItem)) {
         return null;
      } else {
         INativeType var5 = ((INativeDataItem)var4).getType();
         return this.pC.getWildcardTypeManager().create(var5);
      }
   }

   public String pC() {
      ArrayList var1 = new ArrayList(this.getVariables());
      if (var1.isEmpty()) {
         return "(empty)";
      } else {
         Collections.reverse(var1);
         StringBuilder var2 = new StringBuilder();
         int var3 = 0;

         for (IEVar var5 : var1) {
            if (var3 >= 1) {
               var2.append("\n");
            }

            long var6 = var5.getAddress();
            if (var6 < 0L) {
               Strings.ff(var2, "-%04X", -var6);
            } else {
               Strings.ff(var2, "+%04X", var6);
            }

            Strings.ff(var2, ": %2db %s (%s)", var5.getBitsize(), var5.getType(), var5.getName());
            var3++;
         }

         return var2.toString();
      }
   }

   @Override
   public String toString() {
      return this.pC();
   }
}
