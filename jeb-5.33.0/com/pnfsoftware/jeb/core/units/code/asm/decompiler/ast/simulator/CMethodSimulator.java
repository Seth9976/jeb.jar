package com.pnfsoftware.jeb.core.units.code.asm.decompiler.ast.simulator;

import com.pnfsoftware.jeb.core.units.code.asm.decompiler.ast.ICBreak;
import com.pnfsoftware.jeb.core.units.code.asm.decompiler.ast.ICCall;
import com.pnfsoftware.jeb.core.units.code.asm.decompiler.ast.ICContinue;
import com.pnfsoftware.jeb.core.units.code.asm.decompiler.ast.ICDecl;
import com.pnfsoftware.jeb.core.units.code.asm.decompiler.ast.ICGoto;
import com.pnfsoftware.jeb.core.units.code.asm.decompiler.ast.ICLabel;
import com.pnfsoftware.jeb.core.units.code.asm.decompiler.ast.ICMethod;
import com.pnfsoftware.jeb.core.units.code.asm.decompiler.ast.ICStatement;
import com.pnfsoftware.jeb.util.base.Assert;
import com.pnfsoftware.jeb.util.format.Strings;
import com.pnfsoftware.jebglobal.afs;
import com.pnfsoftware.jebglobal.aft;
import com.pnfsoftware.jebglobal.afu;
import com.pnfsoftware.jebglobal.afv;
import com.pnfsoftware.jebglobal.afw;
import com.pnfsoftware.jebglobal.afx;
import com.pnfsoftware.jebglobal.afy;
import com.pnfsoftware.jebglobal.afz;
import com.pnfsoftware.jebglobal.aga;
import com.pnfsoftware.jebglobal.agb;
import com.pnfsoftware.jebglobal.age;
import com.pnfsoftware.jebglobal.agf;
import com.pnfsoftware.jebglobal.agg;
import com.pnfsoftware.jebglobal.agh;
import com.pnfsoftware.jebglobal.agi;
import com.pnfsoftware.jebglobal.agj;
import java.math.BigInteger;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class CMethodSimulator {
   private int traceMaxSize = 16777216;
   private final CEnvironment environment;
   private final List stmtsFlatList;
   private final boolean strictMode;
   private Map uncondBranchTo = new HashMap();

   public CMethodSimulator(ICMethod var1, CEnvironment var2) {
      this(var1, var2, true);
   }

   public CMethodSimulator(ICMethod var1, CEnvironment var2, int var3) {
      this(var1, var2, true);
      this.traceMaxSize = var3;
   }

   public CMethodSimulator(ICMethod var1, CEnvironment var2, boolean var3) {
      Assert.a(var1 != null && var2 != null);
      this.stmtsFlatList = var1.toFlatList();
      this.environment = var2;
      this.strictMode = var3;
      if (!this.strictMode) {
         this.setFlexibleMode(var2);
      }

      this.setParametersValues(var1, var2);
   }

   private void setFlexibleMode(CEnvironment var1) {
      var1.setDefaultPointedSize(4);
      var1.setAutoGenerateUndefinedIdentifierValue(true);
   }

   private void setParametersValues(ICMethod var1, CEnvironment var2) {
      if (var1.getParameters() != null) {
         for (ICDecl var4 : var1.getParameters()) {
            if (!var2.isParameterValueSet(var4.getIdentifier())) {
               var2.setAutoGeneratedParameterValue(var4.getIdentifier());
            }
         }
      }
   }

   public CSimulationLogger simulate() {
      CMethodState var1 = new CMethodState(this.stmtsFlatList);
      return this.simulate(var1);
   }

   public CSimulationLogger simulate(CMethodState var1) {
      Assert.a(var1 != null);
      this.buildUnconditionalControlFlow();
      CSimulationLogger var2 = new CSimulationLogger(this);
      CMethodState var3 = var1;
      int var4 = 0;

      while (this.isNotTerminated(var4)) {
         var4 = this.visitUncondBranches(var4, var2);
         this.emulateStatement(var4, var3, var2);
         var4 = this.updateControlFlow(var4, var3);
      }

      var2.setFinalState(var3);
      var2.setFinalEnvironment(CEnvironment.copy(this.environment));
      return var2;
   }

   private boolean isNotTerminated(int var1) {
      return var1 < this.stmtsFlatList.size();
   }

   private void registerExecutedAddress(int var1, CSimulationLogger var2) {
      this.checkForInfiniteLoop(var2);
      var2.logExecutedIndex(var1);
   }

   private void checkForInfiniteLoop(CSimulationLogger var1) {
      if (var1.getExecutionTrace().size() >= this.traceMaxSize) {
         throw new CSimulationException("simulation too long");
      }
   }

   private int visitUncondBranches(int var1, CSimulationLogger var2) {
      int var3 = var1;

      while (this.uncondBranchTo.containsKey(var3)) {
         this.registerExecutedAddress(var3, var2);
         var3 = (Integer)this.uncondBranchTo.get(var3);
      }

      return var3;
   }

   private void emulateStatement(int var1, CMethodState var2, CSimulationLogger var3) {
      ICStatement var4 = (ICStatement)this.stmtsFlatList.get(var1);
      if (var4 != null) {
         Long var5 = var4.evaluate(var2, this.environment);
         this.registerExecutedAddress(var1, var3);
         if (var4 instanceof age) {
            this.processSwitchControlFlow(var1, var2, (age)var4, BigInteger.valueOf(var5));
         }
      } else {
         throw new CSimulationException("no statement at this index");
      }
   }

   private void processSwitchControlFlow(int var1, CMethodState var2, age var3, BigInteger var4) {
      var2.setControlWord(CMethodState.ControlWord.GOTO_INDEX);
      Integer var5 = this.findCorrespondingSwitchCase(var1, var4);
      if (var5 != null) {
         var2.setControlWordIndex(var5);
      } else {
         var2.setControlWordIndex(this.findCorrespondingSwitchEnd(var1));
      }
   }

   private int updateControlFlow(int var1, CMethodState var2) {
      CMethodState.ControlWord var4 = var2.getControlWord();

      return switch (var4) {
         case GOTO_END_OF_METHOD -> this.stmtsFlatList.size();
         case GOTO_NEXT_INS -> var1 + 1;
         case SKIP_NEXT_BLOCK -> this.findCorrespondingBlockEnd(var1 + 1) + 1;
         case GOTO_PREV_BLOCK -> this.findCorrespondingBlockStart(var1 - 1);
         case GOTO_INDEX -> var2.getControlWordIndex();
         default -> throw new CSimulationException(Strings.ff("TBI: control-word (%s)", var4));
      };
   }

   public static boolean areEquivalentSimulations(CSimulationLogger var0, CSimulationLogger var1) {
      if (!CMethodState.areEquivalent(var0.getFinalState(), var1.getFinalState(), true, true)) {
         return false;
      } else {
         return !CEnvironment.areEquivalent(var0.getFinalEnvironment(), var1.getFinalEnvironment()) ? false : areMethodCallsTheSame(var0, var1);
      }
   }

   private static boolean areMethodCallsTheSame(CSimulationLogger var0, CSimulationLogger var1) {
      List var2 = extractMethodCallNames(var0);
      List var3 = extractMethodCallNames(var1);
      return var2.equals(var3);
   }

   private static List extractMethodCallNames(CSimulationLogger var0) {
      ArrayList var1 = new ArrayList();

      for (Integer var3 : var0.getExecutionTrace()) {
         ICStatement var4 = (ICStatement)var0.getStmtsFlatList().get(var3);
         if (var4 instanceof ICCall) {
            ICMethod var5 = ((ICCall)var4).getMethod();
            if (var5 != null) {
               var1.add(var5.getName());
            }
         }
      }

      return var1;
   }

   private int findCorrespondingBlockEnd(int var1) {
      Assert.a(this.stmtsFlatList.get(var1) instanceof afs);
      int var2 = 0;
      int var3 = var1;

      while (true) {
         ICStatement var4 = (ICStatement)this.stmtsFlatList.get(var3);
         if (var4 instanceof afs) {
            var2++;
         }

         if (var4 instanceof aft) {
            if (--var2 == 0) {
               return var3;
            }
         }

         var3++;
      }
   }

   private int findCorrespondingBlockStart(int var1) {
      Assert.a(this.stmtsFlatList.get(var1) instanceof aft);
      int var2 = 0;
      int var3 = var1;

      while (true) {
         ICStatement var4 = (ICStatement)this.stmtsFlatList.get(var3);
         if (var4 instanceof afs) {
            if (--var2 == 0) {
               return var3;
            }
         }

         if (var4 instanceof aft) {
            var2++;
         }

         var3--;
      }
   }

   private int findCorrespondingSwitchEnd(int var1) {
      Assert.a(this.stmtsFlatList.get(var1) instanceof age);
      int var2 = 0;
      int var3 = var1;

      while (true) {
         ICStatement var4 = (ICStatement)this.stmtsFlatList.get(var3);
         if (var4 instanceof age) {
            var2++;
         }

         if (var4 instanceof agh) {
            if (--var2 == 0) {
               return var3;
            }
         }

         var3++;
      }
   }

   private Integer findCorrespondingSwitchCase(int var1, BigInteger var2) {
      Assert.a(this.stmtsFlatList.get(var1) instanceof age);
      int var3 = 0;
      int var4 = var1 + 1;

      while (true) {
         ICStatement var5 = (ICStatement)this.stmtsFlatList.get(var4);
         if (var5 instanceof age) {
            var3++;
         }

         if (var5 instanceof agh) {
            if (--var3 < 0) {
               return null;
            }
         }

         if (var5 instanceof agf && var3 == 0 && ((agf)var5).A().contains(var2) || var5 instanceof agg && var3 == 0) {
            return var4;
         }

         var4++;
      }
   }

   private void buildUnconditionalControlFlow() {
      this.buildGotoUncondBranches();
      this.buildIfsUncondBranches();
      this.buildLoopsSwitchesUncondBranches();
   }

   private void buildGotoUncondBranches() {
      HashMap var1 = new HashMap();
      int var2 = 0;

      for (ICStatement var4 : this.stmtsFlatList) {
         if (var4 instanceof ICLabel) {
            Assert.a(!var1.containsKey(var4));
            var1.put((ICLabel)var4, var2);
         }

         var2++;
      }

      var2 = 0;

      for (ICStatement var8 : this.stmtsFlatList) {
         if (var8 instanceof ICGoto) {
            ICLabel var5 = ((ICGoto)var8).getLabel();
            Assert.a(var1.containsKey(var5));
            this.uncondBranchTo.put(var2, (Integer)var1.get(var5));
         }

         var2++;
      }
   }

   private void buildIfsUncondBranches() {
      ArrayDeque var1 = new ArrayDeque();
      HashMap var2 = new HashMap();
      int var3 = 0;

      for (ICStatement var5 : this.stmtsFlatList) {
         if (var5 instanceof afy) {
            var1.push(var3);
            var2.put(var3, new ArrayList());
         } else if (var5 instanceof agb) {
            Assert.a(!var1.isEmpty());
            Integer var6 = (Integer)var1.pop();

            for (Integer var8 : (List)var2.get(var6)) {
               this.uncondBranchTo.put(var8, var3);
            }
         } else if (var5 instanceof afz || var5 instanceof aga) {
            Assert.a(!var1.isEmpty());
            Assert.a(this.stmtsFlatList.get(var3 - 1) instanceof aft);
            ((List)var2.get(var1.peek())).add(var3 - 1);
         }

         var3++;
      }
   }

   private void buildLoopsSwitchesUncondBranches() {
      int var1 = 0;
      ArrayDeque var2 = new ArrayDeque();
      ArrayDeque var3 = new ArrayDeque();

      for (ICStatement var5 : this.stmtsFlatList) {
         if (var5 instanceof agi || var5 instanceof afw) {
            int var6 = this.findCorrespondingBlockEnd(var1 + 1);
            this.uncondBranchTo.put(var6, var1);
            var2.push(var6);
            var3.push(var6);
         }

         if (var5 instanceof afu) {
            int var7 = this.findCorrespondingBlockEnd(var1 + 1);
            var2.push(var7);
            var3.push(var7);
         }

         if (var5 instanceof age) {
            int var8 = this.findCorrespondingSwitchEnd(var1);
            var3.push(var8 - 1);
         }

         if (var5 instanceof ICBreak) {
            this.uncondBranchTo.put(var1, (Integer)var3.peek() + 2);
         }

         if (var5 instanceof ICContinue) {
            this.uncondBranchTo.put(var1, (Integer)var2.peek());
         }

         if (var5 instanceof agj || var5 instanceof afx || var5 instanceof afv) {
            var2.pop();
            var3.pop();
         }

         if (var5 instanceof agh) {
            var3.pop();
         }

         var1++;
      }
   }

   public List getStmtsFlatList() {
      return this.stmtsFlatList;
   }
}
